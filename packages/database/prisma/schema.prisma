generator client {
  provider = "prisma-client-js"
  output   = "../../../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

model user {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false)
  image         String?
  password      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  accounts     account[]
  sessions     session[]
  subscription subscription?
  documents    document[]
  images       image[]
  usageLogs    usageLog[]
  jobs         Job[]
  userUsage    UserUsage?
  plan         PlanType  @default(FREE)
  payments     Payment[]

}

model account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  expiresAt             DateTime?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  password              String?
  scope                 String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model session {
  id        String   @id @default(cuid())
  token     String   @unique
  expiresAt DateTime
  userId    String
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier])
}

model subscriptionPlan {
  id    String  @id @default(cuid())
  name  String  @unique // "FREE", "PRO"
  price Decimal @db.Decimal(10, 2)

  // Limits
  dailyDocumentLimit Int // FREE=5, PRO=20
  dailyImageLimit    Int // FREE=5, PRO=20

  mergeFileLimit Int // FREE=2, PRO=-1 (unlimited)

  storageLimitMB Int // FREE=200, PRO=500
  retentionDays  Int // FREE=7, PRO=30

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscriptions subscription[]
}

model subscription {
  id         String             @id @default(cuid())
  userId     String             @unique
  planId     String
  status     SubscriptionStatus @default(ACTIVE)

  startDate  DateTime  @default(now())
  endDate    DateTime?
  canceledAt DateTime?

  // Payments
  provider               PaymentProvider @default(RAZORPAY)
  providerSubscriptionId String?
  providerCustomerId     String?

  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  user user              @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan subscriptionPlan  @relation(fields: [planId], references: [id])

  @@index([userId])
  @@index([planId])
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
  PAYMENT_FAILED
}

model guestUsage {
  id          String  @id @default(cuid())
  ipAddress   String
  fingerprint String?
  userAgent   String?

  documentCount Int @default(0) // 1/day
  imageCount    Int @default(0) // 1/day
  mergeCount    Int @default(0) // NEW â†’ 1 PDF merge/day

  lastResetAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  documents document[]
  images    image[]
  jobs      Job[]

  @@unique([ipAddress, fingerprint])
  @@index([ipAddress])
  @@index([lastResetAt])
}

model UserUsage {
  id          String   @id @default(cuid())
  userId      String   @unique
  user        user     @relation(fields: [userId], references: [id], onDelete: Cascade)

  documentCount Int @default(0)
  imageCount    Int @default(0)
  mergeCount    Int @default(0)

  lastResetAt   DateTime @default(now())

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
}

model document {
  id           String  @id @default(cuid())
  userId       String?
  guestUsageId String?

  originalFileName String
  originalFormat   String
  targetFormat     String?
  fileSize         Int
  s3Key            String
  s3Bucket         String

  status         ProcessingStatus @default(PENDING)
  conversionType ConversionType

  processedS3Key    String?
  processedFileSize Int?
  processingError   String? @db.Text

  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  expiresAt             DateTime

  planSnapshot   String // "GUEST", "FREE", "PRO"
  batchId        String?
  additionalInfo Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       user?       @relation(fields: [userId], references: [id], onDelete: Cascade)
  guestUsage guestUsage? @relation(fields: [guestUsageId], references: [id], onDelete: Cascade)

  mergedAsParent documentMerge[] @relation("MergedMainDocument")
  mergedAsChild  documentMerge[] @relation("MergedChildDocument")

  @@index([userId])
  @@index([guestUsageId])
  @@index([status])
  @@index([expiresAt])
  @@index([createdAt])
}

model image {
  id           String  @id @default(cuid())
  userId       String?
  guestUsageId String?

  originalFileName String
  originalFormat   String
  fileSize         Int
  width            Int
  height           Int
  s3Key            String
  s3Bucket         String

  operation ImageOperation
  status    ProcessingStatus @default(PENDING)

  targetFormat       String?
  targetWidth        Int?
  targetHeight       Int?
  compressionQuality Int?

  processedS3Key    String?
  processedFileSize Int?
  processedWidth    Int?
  processedHeight   Int?
  processingError   String? @db.Text

  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  expiresAt             DateTime

  planSnapshot   String // "GUEST", "FREE", "PRO"
  batchId        String?
  additionalInfo Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       user?       @relation(fields: [userId], references: [id], onDelete: Cascade)
  guestUsage guestUsage? @relation(fields: [guestUsageId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([guestUsageId])
  @@index([status])
  @@index([expiresAt])
  @@index([createdAt])
}

model documentMerge {
  id         String @id @default(cuid())
  documentId String
  mergedId   String
  mergeOrder Int

  document document @relation("MergedMainDocument", fields: [documentId], references: [id])
  merged   document @relation("MergedChildDocument", fields: [mergedId], references: [id])

  @@index([documentId])
  @@index([mergedId])
  @@unique([documentId, mergeOrder])
}

model usageLog {
  id           String  @id @default(cuid())
  userId       String?
  guestUsageId String?

  resourceType ResourceType
  resourceId   String
  operation    String // e.g. "PDF_CONVERT", "MERGE"

  timestamp   DateTime @default(now())
  resetPeriod String // "DAILY"

  user user? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([guestUsageId, timestamp])
  @@index([timestamp])
}

enum ResourceType {
  DOCUMENT
  IMAGE
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum ConversionType {
  FORMAT_CONVERSION
  MERGE
  SPLIT
}

enum ImageOperation {
  FORMAT_CONVERSION
  COMPRESS
  RESIZE
}

model Job {
  id     String    @id @default(cuid())
  type   JobType
  task   String
  status JobStatus @default(QUEUED)
  data   Json
  result Json?
  error  String?   @db.Text

  userId       String?
  guestUsageId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       user?       @relation(fields: [userId], references: [id], onDelete: Cascade)
  guestUsage guestUsage? @relation(fields: [guestUsageId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([guestUsageId])
  @@index([status])
}

enum JobType {
  DOCUMENT
  IMAGE
}

enum JobStatus {
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
}

enum PlanType {
  FREE
  PRO
}

enum PaymentProvider {
  STRIPE
  RAZORPAY
  PAYPAL
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

model Payment {
  id                String        @id @default(cuid())
  userId            String
  amount            Decimal       @db.Decimal(10, 2)
  currency          String        @default("INR")
  provider          PaymentProvider
  providerPaymentId String?       @unique
  providerOrderId   String?
  status            PaymentStatus @default(PENDING)
  metadata          Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user user @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([providerPaymentId])
  @@index([providerOrderId])
}

model WebhookEvent {
  id        String   @id @default(cuid())
  provider  PaymentProvider
  eventType String
  eventId   String? @unique
  payload   Json
  processed Boolean  @default(false)
  error     String?  @db.Text

  createdAt DateTime @default(now())

  @@index([provider, eventType])
}
